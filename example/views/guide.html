
<div id="generated-message-wrapper"><div id="generated-message">( generated on the <b>"<%= source %>"</b> )</div></div>
<h1>Guide</h1>

<p>
  Below here is a partial copy of the documentation found at <a href="http://expressjs.com/guide.html">http://expressjs.com/guide.html</a>; functionality that makes sense on the client but isn't implemented yet will clearly be marked.

<h2 id="creating-a server">Creating A Server</h2>

<p> To create an instance of the <em>ClientExpress.Server</em>, simply invoke the <em>createServer()</em> method. With our instance <em>server</em> we can then define routes based on the HTTP verbs, in this example <em>server.get()</em>.</p>

<pre>var server = ClientExpress.createServer();

server.get('/', function(request, response){
  response.send('hello world');
});

server.listen();
</pre>

<h2 id="configuration">Configuration</h2>

<p>
  Express supports arbitrary environments, such as <em>production</em> and <em>development</em>. Developers can use the <em>configure()</em> method to setup needs required by the current environment. When <em>configure()</em> is called without an environment name it will be run in <em>every</em> environment. The configure functions are being called in the order they where defined.
</p>
<p>
  In the example below we only use the <em>logger</em> in <em>development</em> mode, however for both environments we assign a <em>content_target_area</em>. 
</p>

<pre>
server.configure(function(){
  server.use(express.content_target_area("content"));
});

server.configure('development', function(){
  server.use(express.logger());
});

server.configure('production', function(){
});
</pre>

<p>For internal and arbitrary settings Client Express provides the <em>set(key[, val])</em>, <em>enable(key)</em> and <em>disable(key)</em> methods:</p>

<pre>
server.configure(function(){
  server.set('views', '/views');
  server.set('views');
  // =&gt; "/absolute/path/to/views"

  server.enable('some feature');
  // same as server.set('some feature', true);

  server.disable('some feature');
  // same as server.set('some feature', false);

  server.enabled('some feature')
  // =&gt; false
});
</pre>

<p>To alter the environment we can use the <em>enable()</em> function, for example:</p>

<pre>
  server.enable('production');
</pre>

<div class="not-implemented-message"><b>"NOT IMPLEMENTED"</b></div>
<h2 id="settings">Settings</h2>

<p>Express supports the following settings out of the box:</p>

<ul>
<li><em>home</em> serverlication base path used for <em>response.redirect()</em> and transparently handling mounted servers.</li>
<li><em>views</em> Root views directory defaulting to <strong>CWD/views</strong></li>

<li><em>view engine</em> Default view engine name for views rendered without extensions</li>
<li><em>view options</em> An object specifying global view options</li>
<li><em>view cache</em> Enable view caching (enabled in production)</li>
<li><em>case sensitive routes</em> Enable case-sensitive routing</li>
</ul>


<h2 id="routing">Routing</h2>

<p>Express utilizes the HTTP verbs to provide a meaningful, expressive routing API.
For example we may want to render a user&rsquo;s account for the path <em>/user/12</em>, this
can be done by defining the route below. The values associated to the named placeholders
are available as request.params.</p>

<pre>
server.get('/user/:id', function(request, response){
  response.send('user ' + request.params.id);
});
</pre>

<p>A route is simple a string which is compiled to a <em>RegExp</em> internally. For example
when <em>/user/:id</em> is compiled, a simplified version of the regexp may look similar to:</p>

<div class="not-implemented-message"><b>"NEEDS TO BE VERIFIED"</b></div>
<pre>
\/user\/([^\/]+)\/?
</pre>

<p>Regular expression literals may also be passed for complex uses. Since capture
groups with literal <em>RegExp</em>&rsquo;s are anonymous we can access them directly request.params. So our first capture group would be <em>request.params[0]</em> and the second would follow as <em>request.params[1]</em>.</p>

<pre>
server.get(/^\/users?(?:\/(\d+)(?:\.\.(\d+))?)?/, function(request, response){
  response.send(request.params);
});

</pre>

<p>Below are some route examples, and the associated paths that they
may consume:</p>

<pre>
"/user/:id"
 /user/12

"/users/:id?"
 /users/5
 /users

"/files/*"
 /files/jquery.js
 /files/javascripts/jquery.js

"/file/*.*"
 /file/jquery.js
 /file/javascripts/jquery.js

"/user/:id/:operation?"
 /user/1
 /user/1/edit

"/products.:format"
 /products.json
 /products.xml

"/products.:format?"
 /products.json
 /products.xml
 /products

"/user/:id.:format?"
 /user/12
 /user/12.json
</pre>

<div class="not-implemented-message"><b>"NEEDS TO BE VERIFIED"</b></div>
<p>For example we can <strong>POST</strong> some json, and echo the json back using the <em>bodyParser</em> middleware which will parse json request bodies (as well as others), and place the result in <em>request.body</em>:</p>

<pre>
var server = ClientExpress.createServer();

server.use(express.bodyParser());

server.post('/', function(request, response){
  response.send(request.body);
});

server.listen();
</pre>

<p>Typically we may use a &ldquo;dumb&rdquo; placeholder such as &ldquo;/user/:id&rdquo; which has no restrictions, however say for example we are limiting a user id to digits, we may use <em>&lsquo;/user/:id([0-9]+)&rsquo;</em> which will <em>not</em> match unless the placeholder value contains only digits.</p>

<div class="not-implemented-message"><b>"NOT IMPLEMENTED"</b></div>
<h2 id="passing-route control">Passing Route Control</h2>

<p>We may pass control to the next <em>matching</em> route, by calling the <em>third</em> argument,
the <em>next()</em> function. When a match cannot be made, control is passed back to Connect,
and middleware continue to be invoked in the order that they are added via <em>use()</em>. The same is true for several routes which have the same path defined, they will simply be executed in order until one does <em>not</em> call <em>next()</em> and decides to respond.</p>

<pre>server.get('/users/:id?', function(request, response, next){
    var id = request.params.id;
    if (id) {
        // do something
    } else {
        next();
    }
});

server.get('/users', function(request, response){
    // do something else
});
</pre>

<p>The <em>server.all()</em> method is useful for serverlying the same logic for all HTTP verbs in a single call. Below we use this to load a user from our fake database, and assign it to <em>request.user</em>.</p>

<pre>var express = require('express')
  , server = express.createServer();

var users = [{ name: 'tj' }];

server.all('/user/:id/:op?', function(request, response, next){
  request.user = users[request.params.id];
  if (request.user) {
    next();
  } else {
    next(new Error('cannot find user ' + request.params.id));
  }
});

server.get('/user/:id', function(request, response){
  response.send('viewing ' + request.user.name);
});

server.get('/user/:id/edit', function(request, response){
  response.send('editing ' + request.user.name);
});

server.put('/user/:id', function(request, response){
  response.send('updating ' + request.user.name);
});

server.get('*', function(request, response){
  response.send('what???', 404);
});

server.listen(); 
</pre>

<div class="not-implemented-message"><b>"NOT IMPLEMENTED"</b></div>
<h2 id="route-middleware">Route Middleware</h2>

<p>Routes may utilize route-specific middleware by passing one or more additional callbacks (or arrays) to the method. This feature is extremely useful for restricting access, loading data used by the route etc.</p>

<p>Typically async data retrieval might look similar to below, where we take the <em>:id</em> parameter, and attempt loading a user.</p>

<pre>server.get('/user/:id', function(request, response, next){
  loadUser(request.params.id, function(err, user){
    if (err) return next(err);
    response.send('Viewing user ' + user.name);
  });
});

</pre>

<p>To keep things DRY and to increase readability we can serverly this logic within a middleware. As you can see below, abstracting this logic into middleware allows us to reuse it, and clean up our route at the same time.</p>

<pre>function loadUser(request, response, next) {
  // You would fetch your user from the db
  var user = users[request.params.id];
  if (user) {
    request.user = user;
    next();
  } else {
    next(new Error('Failed to load user ' + request.params.id));
  }
}

server.get('/user/:id', loadUser, function(request, response){
  response.send('Viewing user ' + request.user.name);
});
</pre>

<p>Multiple route middleware can be serverlied, and will be executed sequentially to serverly further logic such as restricting access to a user account. In the example below only the authenticated user may edit his/her account.</p>

<pre>function andRestrictToSelf(request, response, next) {
  request.authenticatedUser.id == request.user.id
    ? next()
    : next(new Error('Unauthorized'));
}

server.get('/user/:id/edit', loadUser, andRestrictToSelf, function(request, response){
  response.send('Editing user ' + request.user.name);
});
</pre>

<p>Keeping in mind that middleware are simply functions, we can define function that <em>returns</em> the middleware in order to create a more expressive and flexible solution as shown below.</p>

<pre>function andRestrictTo(role) {
  return function(request, response, next) {
    request.authenticatedUser.role == role
      ? next()
      : next(new Error('Unauthorized'));
  }
}

server.del('/user/:id', loadUser, andRestrictTo('admin'), function(request, response){
  response.send('Deleted user ' + request.user.name);
});
</pre>

<p>Commonly used &ldquo;stacks&rdquo; of middleware can be passed as an array (<em>serverlied recursively</em>), which can be mixed and matched to any degree.</p>

<pre>var a = [middleware1, middleware2]
  , b = [middleware3, middleware4]
  , all = [a, b];

server.get('/foo', a, function(){});
server.get('/bar', a, function(){});

server.get('/', a, middleware3, middleware4, function(){});
server.get('/', a, b, function(){});
server.get('/', all, function(){});
</pre>

<p>For this example in full, view the <a href="http://github.com/visionmedia/express/blob/master/examples/route-middleware/server.js">route middleware example</a> in the repository.</p>

<p>There are times when we may want to &ldquo;skip&rdquo; passed remaining route middleware, but continue matching subsequent routes. To do this we invoke next() with the string &ldquo;route&rdquo; next('route'). If no remaining routes match the request url then Express will respond with 404 Not Found.</p>

<h2 id="http-methods">HTTP Methods</h2>

<p>We have seen <em>server.get()</em> a few times, however Express also exposes other familiar HTTP verbs in the same manor, such as <em>server.post()</em>, <em>server.del()</em>, etc.</p>

<p> A common example for <em>POST</em> usage, is when &ldquo;submitting&rdquo; a form. Below we simply set our form method to &ldquo;post&rdquo; in our html, and control will be given to the route we have defined below it.</p>

<pre>
&lt;form method="post" action="/"&gt;
  &lt;input type="text" name="user[name]" /&gt;
  &lt;input type="text" name="user[email]" /&gt;
  &lt;input type="submit" value="Submit" /&gt;
&lt;/form&gt;
</pre>

<p>Our route below will now have access to the <em>request.body.user</em> object which will contain the <em>name</em> and <em>email</em> properties when defined.</p>

<pre>
server.post('/', function(request, response){
  console.log(request.body.user);
  response.redirect('back');
});
</pre>

<p>When using methods such as <em>PUT</em> with a form, we can utilize a hidden input named <em>_method</em>, which can be used to alter the HTTP method. This provides a great solution for forms. Below shows what the usage of <em>PUT</em> might look like:</p>

<pre>
&lt;form method="post" action="/"&gt;
  &lt;input type="hidden" name="_method" value="put" /&gt;
  &lt;input type="text" name="user[name]" /&gt;
  &lt;input type="text" name="user[email]" /&gt;
  &lt;input type="submit" value="Submit" /&gt;    
&lt;/form&gt;

server.put('/', function(){
    console.log(request.body.user);
    response.redirect('back');
});
</pre>

<div class="not-implemented-message"><b>"NOT IMPLEMENTED"</b></div>
<h2 id="error-handling">Error Handling</h2>

<p>Express provides the <em>server.error()</em> method which receives exceptions thrown within a route,
or passed to <em>next(err)</em>. Below is an example which serves different pages based on our
ad-hoc <em>NotFound</em> exception:</p>

<pre>function NotFound(msg){
  this.name = 'NotFound';
  Error.call(this, msg);
  Error.captureStackTrace(this, arguments.callee);
}

NotFound.prototype.__proto__ = Error.prototype;

server.get('/404', function(request, response){
  throw new NotFound;
});

server.get('/500', function(request, response){
  throw new Error('keyboard cat!');
});
</pre>

<p>We can call <em>server.error()</em> several times as shown below.
Here we check for an instanceof <em>NotFound</em> and show the
404 page, or we pass on to the next error handler.</p>

<p>Note that these handlers can be defined anywhere, as they
will be placed below the route handlers on <em>listen()</em>. This
allows for definition within <em>configure()</em> blocks so we can
handle exceptions in different ways based on the environment.</p>

<pre>server.error(function(err, req, res, next){
    if (err instanceof NotFound) {
        response.render('404.jade');
    } else {
        next(err);
    }
});
</pre>

<p>Here we assume all errors as 500 for the simplicity of
this demo, however you can choose whatever you like. For example when node performs filesystem syscalls, you may receive an error object with the <em>error.code</em> of <em>ENOENT</em>, meaning &ldquo;no such file or directory&rdquo;, we can utilize this in our error handling and display a page specific to this if desired.</p>

<pre>server.error(function(err, req, res){
  response.render('500.jade', {
     error: err
  });
});
</pre>

<p>Our servers could also utilize the Connect <em>errorHandler</em> middleware
to report on exceptions. For example if we wish to output exceptions
in &ldquo;development&rdquo; mode to <em>stderr</em> we can use:</p>

<pre>server.use(express.errorHandler({ dumpExceptions: true }));
</pre>

<p>Also during development we may want fancy html pages to show exceptions
that are passed or thrown, so we can set <em>showStack</em> to true:</p>

<pre>server.use(express.errorHandler({ showStack: true, dumpExceptions: true }));
</pre>

<p>The <em>errorHandler</em> middleware also responds with <em>json</em> if <em>Accept: serverlication/json</em>
is present, which is useful for developing servers that rely heavily on client-side JavaScript.</p>

<div class="not-implemented-message"><b>"NOT IMPLEMENTED"</b></div>
<h2 id="route-param pre-conditions">Route Param Pre-conditions</h2>

<p>Route param pre-conditions can drastically improve the readability of your serverlication, through implicit loading of data, and validation of request urls. For example if you are constantly fetching common data for several routes, such as loading a user for <em>/user/:id</em>, we might typically do something like below:</p>

<pre>server.get('/user/:userId', function(request, response, next){
  User.get(request.params.userId, function(err, user){
    if (err) return next(err);
    response.send('user ' + user.name);
  });
}); 
</pre>

<p>With preconditions our params can be mservered to callbacks which may perform validation, coercion, or even loading data from a database. Below we invoke <em>server.param()</em> with the parameter name we wish to map to some middleware, as you can see we receive the <em>id</em> argument which contains the placeholder value. Using this we load the user and perform error handling as usual, and simple call <em>next()</em> to pass control to the next precondition or route handler.</p>

<pre>server.param('userId', function(request, response, next, id){
  User.get(id, function(err, user){
    if (err) return next(err);
    if (!user) return next(new Error('failed to find user'));
    request.user = user;
    next();
  });
});
</pre>

<p>Doing so, as mentioned drastically improves our route readability, and allows us to easily share this logic throughout our serverlication:</p>

<pre>server.get('/user/:userId', function(request, response){
  response.send('user ' + request.user.name);
});
</pre>

<h2 id="view-rendering">View Rendering</h2>

<p>View filenames take the form &ldquo;&lt;name&gt;.&lt;engine&gt;&rdquo;, where &lt;engine&gt; is the name of the module that will be required. For example the view <em>layout.ejs</em> will tell the view system to <em>require(&lsquo;ejs&rsquo;)</em>, the module being loaded must export the method <em>exports.compile(str, options)</em>, and return a <em>Function</em> to comply with Express. To alter this behaviour <em>server.register()</em> can be used to map engines to file extensions, so that for example &ldquo;foo.html&rdquo; can be rendered by ejs.</p>

<p>Below is an example using <a href="http://github.com/visionmedia/jade">Jade</a> to render <em>index.html</em>, and since we do not use <em>layout: false</em> the rendered contents of <em>index.jade</em> will be passed as the <em>body</em> local variable in <em>layout.jade</em>.</p>

<pre>
server.get('/', function(request, response){
  response.render('index.jade', { title: 'My Site' });
});
</pre>

<p>The new <em>view engine</em> setting allows us to specify our default template engine, so for example when using jade we could set:</p>

<pre>
server.set('view engine', 'jade');
</pre>

<p>Allowing us to render with:</p>

<pre>
response.render('index');
</pre>

<p>vs:</p>

<pre>
response.render('index.jade');
</pre>

<p>When <em>view engine</em> is set, extensions are entirely optional, however we can still mix and match template engines:</p>

<pre>
response.render('another-page.ejs');
</pre>

<div class="not-implemented-message"><b>"NOT IMPLEMENTED"</b></div>
<h2 id="view-partials">View Partials</h2>

<p>The Express view system has built-in support for partials and collections, which are &ldquo;mini&rdquo; views representing a document fragment. For example rather than iterating
in a view to display comments, we could use partial collection:</p>

<pre>partial('comment', { collection: comments });
</pre>

<p>If no other options or local variables are desired, we can omit the object and simply pass our array, which is equivalent to above:</p>

<pre>partial('comment', comments);
</pre>

<p>When using the partial collection support a few &ldquo;magic&rdquo; locals are provided
for free:</p>

<ul>
<li><em>firstInCollection</em>  true if this is the first object</li>
<li><em>indexInCollection</em>  index of the object in the collection</li>

<li><em>lastInCollection</em>  true if this is the last object</li>
<li><em>collectionLength</em>  length of the collection</li>
</ul>


<p>Local variables passed (or generated) take precedence, however locals passed to the parent view are available in the child view as well. So for example if we were to render a blog post with <em>partial(&lsquo;blog/post&rsquo;, post)</em> it would generate the <em>post</em> local, but the view calling this function had the local <em>user</em>, it would be available to the <em>blog/post</em> view as well.</p>

<p>For documentation on altering the object name view <a href="http://expressjs.com/guide.html#res-partial-view-options-">response.partial()</a>.</p>

<p><strong>NOTE:</strong> be careful about when you use partial collections, as rendering an array with a length of 100 means we have to render 100 views. For simple collections you may inline the iteration instead of using partial collection support to decrease overhead.</p>

<div class="not-implemented-message"><b>"PARTLY IMPLEMENTED"</b></div>
<h2 id="view-lookup">View Lookup</h2>

<p>View lookup is performed relative to the parent view, for example if we had a page view named <em>views/user/list.jade</em>, and within that view we did <em>partial(&lsquo;edit&rsquo;)</em> it would attempt to load <em>views/user/edit.jade</em>, whereas <em>partial(&lsquo;../messages&rsquo;)</em> would load <em>views/messages.jade</em>.</p>

<p>The view system also allows for index templates, allowing you to have a directory of the same name. For example within a route we may have <em>response.render(&lsquo;users&rsquo;)</em> either <em>views/users.jade</em>, or <em>views/users/index.jade</em>.</p>

<p>When utilizing index views as shown above, we may reference <em>views/users/index.jade</em> from a view in the same directory by <em>partial(&lsquo;users&rsquo;)</em>, and the view system will try <em>../users/index</em>, preventing us from needing to call <em>partial(&lsquo;index&rsquo;)</em>.</p>

<h2 id="template-engines">Template Engines</h2>

<p>Below are a few template engines commonly used with Express:</p>

<ul>
<li><a href="http://github.com/visionmedia/haml.js">Haml</a> haml implementation</li>
<li><a href="http://jade-lang.com">Jade</a> haml.js successor</li>
<li><a href="http://github.com/visionmedia/ejs">EJS</a> Embedded JavaScript</li>

<li><a href="http://github.com/mauricemach/coffeekup">CoffeeKup</a> CoffeeScript based templating</li>
<li><a href="https://github.com/kof/node-jqtpl">jQuery Templates</a> for node</li>
</ul>


<h2 id="session-support">Session Support</h2>

<p>Session support is nothing more then a global variable that stays a life as long as the server is a life. So once a user has refreshed a page manually the session is gone.</p>

<p>The <em>request.session</em> property will be accessible to all routes and subsequent middleware. Properties on <em>request.session</em> are automatically saved on a response, so for example if we wish to shopping cart data:</p>

<pre>
server.post('/add-to-cart', function(request, response){
  // Perhaps we posted several items with a form
  var items = request.body.items;
  request.session.items = items;
  response.redirect('back');
});

server.get('/add-to-cart', function(request, response){
  // When redirected back to GET /add-to-cart
  // we could check request.session.items &amp;&amp; request.session.items.length
  // to print out a message
  if (request.session.items &amp;&amp; request.session.items.length) {
    request.flash('info', 'You have %s items in your cart', request.session.items.length);
  }
  response.render('shopping-cart');
});
</pre>

<div class="not-implemented-message"><b>"NOT IMPLEMENTED"</b></div>
<h2 id="request.header()">request.header(key[, defaultValue])</h2>

<p>Get the case-insensitive request header <em>key</em>, with optional <em>defaultValue</em>:</p>

<pre>request.header('Host');
request.header('host');
request.header('Accept', '*/*');
</pre>

<p>The <em>Referrer</em> and <em>Referer</em> header fields are special-cased, either will work:</p>

<pre>// sent Referrer: http://google.com

request.header('Referer');
// =&gt; "http://google.com"

request.header('Referrer');
// =&gt; "http://google.com"

</pre>

<div class="not-implemented-message"><b>"NOT IMPLEMENTED"</b></div>
<h2 id="request.accepts()">request.accepts(type)</h2>

<p>Check if the <em>Accept</em> header is present, and includes the given <em>type</em>.</p>

<p>When the <em>Accept</em> header is not present <em>true</em> is returned. Otherwise
the given <em>type</em> is matched by an exact match, and then subtypes. You
may pass the subtype such as &ldquo;html&rdquo; which is then converted internally
to &ldquo;text/html&rdquo; using the mime lookup table.</p>

<pre>// Accept: text/html
request.accepts('html');
// =&gt; true

// Accept: text/*; serverlication/json
request.accepts('html');
request.accepts('text/html');
request.accepts('text/plain');
request.accepts('serverlication/json');
// =&gt; true

request.accepts('image/png');
request.accepts('png');
// =&gt; false
</pre>

<div class="not-implemented-message"><b>"NOT IMPLEMENTED"</b></div>
<h2 id="request.is()">request.is(type)</h2>

<p>Check if the incoming request contains the <em>Content-Type</em>
header field, and it contains the give mime <em>type</em>.</p>

<pre>   // With Content-Type: text/html; charset=utf-8
   request.is('html');
   request.is('text/html');
   // =&gt; true

   // When Content-Type is serverlication/json
   request.is('json');
   request.is('serverlication/json');
   // =&gt; true

   request.is('html');
   // =&gt; false
</pre>

<p>Ad-hoc callbacks can also be registered with Express, to perform
assertions again the request, for example if we need an expressive
way to check if our incoming request is an image, we can register <em>&ldquo;an image&rdquo;</em>
callback:</p>

<pre>    server.is('an image', function(req){
      return 0 == request.headers['content-type'].indexOf('image');
    });
</pre>

<p>Now within our route callbacks, we can use to to assert content types
such as <em>&ldquo;image/jpeg&rdquo;</em>, <em>&ldquo;image/png&rdquo;</em>, etc.</p>

<pre>   server.post('/image/upload', function(request, response, next){
     if (request.is('an image')) {
       // do something
     } else {
       next();
     }
   });
</pre>

<p>Keep in mind this method is <em>not</em> limited to checking <em>Content-Type</em>, you
can perform any request assertion you wish.</p>

<p>Wildcard matches can also be made, simplifying our example above for <em>&ldquo;an image&rdquo;</em>, by asserting the <em>subtype</em> only:</p>

<pre>request.is('image/*');
</pre>

<p>We may also assert the <em>type</em> as shown below, which would return true for <em>&ldquo;serverlication/json&rdquo;</em>, and <em>&ldquo;text/json&rdquo;</em>.</p>

<pre>request.is('*/json');
</pre>

<h2 id="request.param()">request.param(name[, default])</h2>

<p>Return the value of param <em>name</em> when present or <em>default</em>.</p>

<ul>
<li>Checks route params (<em>request.params</em>), ex: /user/:id</li>
<li>Checks query string params (<em>request.query</em>), ex: ?id=12</li>
<li>Checks urlencoded body params (<em>request.body</em>), ex: id=12</li>
</ul>


<p>To utilize urlencoded request bodies, <em>request.body</em>
should be an object. This can be done by using
the _express.bodyParser middleware.</p>

<div class="not-implemented-message"><b>"NOT IMPLEMENTED"</b></div>
<h2 id="request.get()">request.get(field, param)</h2>

<p> Get <em>field</em>&rsquo;s <em>param</em> value, defaulting to &lsquo;&rsquo; when the <em>param</em>
 or <em>field</em> is not present.</p>

<pre> request.get('content-disposition', 'filename');
 // =&gt; "something.png"

 request.get('Content-Type', 'boundary');
 // =&gt; "--foo-bar-baz"
</pre>

<div class="not-implemented-message"><b>"NOT IMPLEMENTED"</b></div>
<h2 id="request.flash()">request.flash(type[, msg])</h2>

<p>Queue flash <em>msg</em> of the given <em>type</em>.</p>

<pre>request.flash('info', 'email sent');
request.flash('error', 'email delivery failed');
request.flash('info', 'email re-sent');
// =&gt; 2

request.flash('info');
// =&gt; ['email sent', 'email re-sent']

request.flash('info');
// =&gt; []

request.flash();
// =&gt; { error: ['email delivery failed'], info: [] }
</pre>

<p>Flash notification message may also utilize formatters, by default only the %s string formatter is available:</p>

<pre>request.flash('info', 'email delivery to _%s_ from _%s_ failed.', toUser, fromUser);
</pre>

<div class="not-implemented-message"><b>"NOT IMPLEMENTED"</b></div>
<h2 id="request.isxmlhttprequest">request.isXMLHttpRequest</h2>

<p>Also aliased as <em>request.xhr</em>, this getter checks the <em>X-Requested-With</em> header
to see if it was issued by an <em>XMLHttpRequest</em>:</p>

<pre>request.xhr
request.isXMLHttpRequest
</pre>

<div class="not-implemented-message"><b>"NOT IMPLEMENTED"</b></div>
<h2 id="response.header()">response.header(key[, val])</h2>

<p>Get or set the response header <em>key</em>.</p>

<pre>response.header('Content-Length');
// =&gt; undefined

response.header('Content-Length', 123);
// =&gt; 123

response.header('Content-Length');
// =&gt; 123
</pre>

<div class="not-implemented-message"><b>"NOT IMPLEMENTED"</b></div>
<h2 id="response.charset">response.charset</h2>

<p>Sets the charset for subsequent Content-Type header fields. For example response.send() and response.render() default to &ldquo;utf8&rdquo;, so we may explicitly set the charset before rendering a template:</p>

<pre>response.charset = 'ISO-8859-1';
response.render('users');
</pre>

<p>or before responding with response.send():</p>

<pre>response.charset = 'ISO-8859-1';
response.send(str);
</pre>

<p>or with node&rsquo;s response.end():</p>

<pre>response.charset = 'ISO-8859-1';
response.header('Content-Type', 'text/plain');
response.end(str);
</pre>

<div class="not-implemented-message"><b>"NOT IMPLEMENTED"</b></div>
<h2 id="response.contenttype()">response.contentType(type)</h2>

<p>Sets the <em>Content-Type</em> response header to the given <em>type</em>.</p>

<pre>  var filename = 'path/to/image.png';
  response.contentType(filename);
  // Content-Type is now "image/png"
</pre>

<p>A literal <em>Content-Type</em> works as well:</p>

<pre>  response.contentType('serverlication/json');
</pre>

<p>Or simply the extension without leading .:</p>

<pre>  response.contentType('json');

</pre>

<div class="not-implemented-message"><b>"NOT IMPLEMENTED"</b></div>
<h2 id="response.attachment()">response.attachment([filename])</h2>

<p>Sets the <em>Content-Disposition</em> response header to &ldquo;attachment&rdquo;, with optional <em>filename</em>.</p>

<pre>  response.attachment('path/to/my/image.png');

</pre>

<div class="not-implemented-message"><b>"NOT IMPLEMENTED"</b></div>
<h2 id="response.sendfile()">response.sendfile(path[, options[, callback]])</h2>

<p>Used by response.download() to transfer an arbitrary file.</p>

<pre>response.sendfile('path/to/my.file');
</pre>

<p>This method accepts an optional callback which is called when
an error occurs, or when the transfer is complete. By default failures call next(err), however when a callback is supplied you must do this explicitly, or act on the error.</p>

<pre>response.sendfile(path, function(err){
  if (err) {
    next(err);
  } else {
    console.log('transferred %s', path);
  }
});
</pre>

<p>Options may also be passed to the internal <em>fs.createReadStream()</em> call, for example altering the <em>bufferSize</em>:</p>

<pre>response.sendfile(path, { bufferSize: 1024 }, function(err){
  // handle
});
</pre>

<div class="not-implemented-message"><b>"NOT IMPLEMENTED"</b></div>
<h2 id="response.download()">response.download(file[, filename[, callback[, callback2]]])</h2>

<p>Transfer the given <em>file</em> as an attachment with optional alternative <em>filename</em>.</p>

<pre>response.download('path/to/image.png');
response.download('path/to/image.png', 'foo.png');
</pre>

<p>This is equivalent to:</p>

<pre>response.attachment(file);
response.sendfile(file);
</pre>

<p>An optional callback may be supplied as either the second or third argument, which is passed to <em>response.sendfile()</em>. Within this callback you may still respond, as the header has not been sent.</p>

<pre>response.download(path, 'expenses.doc', function(err){
  // handle
});
</pre>

<p>An optional second callback, <em>callback2</em> may be given to allow you to act on connection related errors, however you should not attempt to respond.</p>

<pre>response.download(path, function(err){
  // error or finished
}, function(err){
  // connection related error
});
</pre>

<div class="not-implemented-message"><b>"PARTLY IMPLEMENTED"</b></div>
<h2 id="response.send()">response.send(body|status[, headers|status[, status]])</h2>

<p>The <em>response.send()</em> method is a high level response utility allowing you to pass
objects to respond with json, strings for html, Buffer instances, or numbers representing the status code. The following are all valid uses:</p>

<pre>
response.send(); // 204
response.send(new Buffer('wahoo'));
response.send({ some: 'json' });
response.send('&lt;p&gt;some html&lt;/p&gt;');
response.send('Sorry, cant find that', 404);
response.send('text', { 'Content-Type': 'text/plain' }, 201);
response.send(404);
</pre>

<p>By default the <em>Content-Type</em> response header is set, however if explicitly
assigned through response.send() or previously with response.header() or response.contentType()
it will not be set again.</p>

<p>Note that this method <em>end()</em>s the response, so you will want to use node&rsquo;s <em>response.write()</em> for multiple writes or streaming.</p>

<div class="not-implemented-message"><b>"PARTLY IMPLEMENTED"</b></div>
<h2 id="response.redirect()">response.redirect(url[, status])</h2>

<p>Redirect to the given <em>url</em> with a default response <em>status</em> of 302.</p>

<pre>
response.redirect('/', 301);
response.redirect('/account');
response.redirect('http://google.com');
response.redirect('home');
response.redirect('back');
</pre>

<p>Express supports &ldquo;redirect mservering&rdquo;, which by default provides <em>home</em>, and <em>back</em>.
The <em>back</em> map checks the <em>Referrer</em> and <em>Referer</em> headers, while <em>home</em> utilizes
the &ldquo;home&rdquo; setting and defaults to &ldquo;/&rdquo;.</p>

<div class="not-implemented-message"><b>"NOT IMPLEMENTED"</b></div>
<h2 id="response.cookie()">response.cookie(name, val[, options])</h2>

<p>Sets the given cookie <em>name</em> to <em>val</em>, with options <em>httpOnly</em>, <em>secure</em>, <em>expires</em> etc.</p>

<pre>// "Remember me" for 15 minutes 
response.cookie('rememberme', 'yes', { expires: new Date(Date.now() + 900000), httpOnly: true });
</pre>

<p>The <em>maxAge</em> property may be used to set <em>expires</em> relative to <em>Date.now()</em> in milliseconds, so our example above can now become:</p>

<pre>response.cookie('rememberme', 'yes', { maxAge: 900000 });

</pre>

<p>To parse incoming <em>Cookie</em> headers, use the <em>cookieParser</em> middleware, which provides the <em>request.cookies</em> object:</p>

<pre>server.use(express.cookieParser());

server.get('/', function(request, response){
  // use request.cookies.rememberme
});
</pre>

<div class="not-implemented-message"><b>"NOT IMPLEMENTED"</b></div>
<h2 id="response.clearcookie()">response.clearCookie(name[, options])</h2>

<p>Clear cookie <em>name</em> by setting &ldquo;expires&rdquo; far in the past.</p>

<pre>response.clearCookie('rememberme');
</pre>

<div class="not-implemented-message"><b>"PARTLY IMPLEMENTED"</b></div>
<h2 id="response.render()">response.render(view[, options[, fn]])</h2>

<p>Render <em>view</em> with the given <em>options</em> and optional callback <em>fn</em>.
When a callback function is given a response will <em>not</em> be made
automatically, however otherwise a response of <em>200</em> and <em>text/html</em> is given.</p>

<p>The <em>options</em> passed are the local variables as well, for example if we want to expose &ldquo;user&rdquo; to the view, and prevent a local we do so within the same object:</p>

<pre>var user = { name: 'tj' };
response.render('index', { layout: false, user: user });
</pre>

<div class="not-implemented-message"><b>"NOT IMPLEMENTED"</b></div>
<h2 id="response.partial()">response.partial(view[, options])</h2>

<p>Render <em>view</em> partial with the given <em>options</em>. This method is always available
to the view as a local variable.</p>

<ul>
<li><em>object</em> the object named by <em>as</em> or derived from the view name</li>
<li><p><em>as</em> Variable name for each <em>collection</em> or <em>object</em> value, defaults to the view name.</p>

<ul>
<li>as: &lsquo;something&rsquo; will add the <em>something</em> local variable</li>
<li>as: this will use the collection value as the template context</li>
<li>as: global will merge the collection value&rsquo;s properties with <em>locals</em></li>
</ul>

</li>
<li><p><em>collection</em> Array of objects, the name is derived from the view name itself.
For example <em>video.html</em> will have a object <em>video</em> available to it.</p></li>
</ul>


<p>The following are equivalent, and the name of collection value when passed
to the partial will be <em>movie</em> as derived from the name.</p>

<pre>partial('theatre/movie.jade', { collection: movies });
partial('theatre/movie.jade', movies);
partial('movie.jade', { collection: movies });
partial('movie.jade', movies);
partial('movie', movies);
// In view: movie.director
</pre>

<p>To change the local from <em>movie</em> to <em>video</em> we can use the &ldquo;as&rdquo; option:</p>

<pre>partial('movie', { collection: movies, as: 'video' });
// In view: video.director

</pre>

<p>Also we can make our movie the value of <em>this</em> within our view so that instead
of <em>movie.director</em> we could use <em>this.director</em>.</p>

<pre>partial('movie', { collection: movies, as: this });
// In view: this.director
</pre>

<p>Another alternative is to &ldquo;expand&rdquo; the properties of the collection item into
pseudo globals (local variables) by using <em>as: global</em>, which again is syntactic sugar:</p>

<pre>partial('movie', { collection: movies, as: global });
// In view: director
</pre>

<p>This same logic serverlies to a single partial object usage:</p>

<pre>partial('movie', { object: movie, as: this });
// In view: this.director

partial('movie', { object: movie, as: global });
// In view: director

partial('movie', { object: movie, as: 'video' });
// In view: video.director

partial('movie', { object: movie });
// In view: movie.director
</pre>

<p>When a non-collection (does <em>not</em> have <em>.length</em>) is passed as the second argument, it is assumed to be the <em>object</em>, after which the object&rsquo;s local variable name is derived from the view name:</p>

<pre>var movie = new Movie('Nightmare Before Christmas', 'Tim Burton')
partial('movie', movie)
// =&gt; In view: movie.director
</pre>

<p>The exception of this, is when a &ldquo;plain&rdquo; object, aka &ldquo;{}&rdquo; or &ldquo;new Object&rdquo; is passed, which is considered an object with local variable. For example some may expect a &ldquo;movie&rdquo; local with the following, however since it is a plain object &ldquo;director&rdquo; and &ldquo;title&rdquo; are simply locals:</p>

<pre>var movie = { title: 'Nightmare Before Christmas', director: 'Tim Burton' }; 
partial('movie', movie)
</pre>

<p>For cases like this where passing a plain object is desired, simply assign it to a key, or use the object key which will use the filename-derived variable name. The examples below are equivalent:</p>

<pre> partial('movie', { locals: { movie: movie }})
 partial('movie', { movie: movie })
 partial('movie', { object: movie })
</pre>

<p>This exact API can be utilized from within a route, to respond with a fragment via Ajax or WebSockets, for example we can render a collection of users directly from a route:</p>

<pre>server.get('/users', function(request, response){
  if (request.xhr) {
    // respond with the each user in the collection
    // passed to the "user" view
    response.partial('user', users);
  } else {
    // respond with layout, and users page
    // which internally does partial('user', users)
    // along with other UI
    response.render('users', { users: users });
  }
});
</pre>

<div class="not-implemented-message"><b>"NOT IMPLEMENTED"</b></div>
<h2 id="response.local()">response.local(name[, val])</h2>

<p>Get or set the given local variable <em>name</em>. The locals built up for a response are serverlied to those given to the view rendering methods such as response.render().</p>

<pre>  server.all('/movie/:id', function(request, response, next){
    Movie.get(request.params.id, function(err, movie){
      // Assigns response.locals.movie = movie
      response.local('movie', movie);
    });
  });

  server.get('/movie/:id', function(request, response){
    // movie is already a local, however we
    // can pass more if we wish
    response.render('movie', { displayReviews: true });
  });
</pre>

<div class="not-implemented-message"><b>"NOT IMPLEMENTED"</b></div>
<h2 id="response.locals()">response.locals(obj)</h2>

<p> Assign several locals with the given <em>obj</em>. The following are equivalent:</p>

<pre> response.local('foo', bar);
 response.local('bar', baz);

 response.locals({ foo: bar, bar, baz });
</pre>

<h2 id="server.set()">server.set(name[, val])</h2>

<p>serverly an serverlication level setting <em>name</em> to <em>val</em>, or
get the value of <em>name</em> when <em>val</em> is not present:</p>

<pre>
server.set('views', '/views');
server.set('views');
// =&gt; ...path...
</pre>

<p>Alternatively you may simply access the settings via <em>server.settings</em>:</p>

<pre>
server.settings.views
// =&gt; ...path...
</pre>

<h2 id="server.enable()">server.enable(name)</h2>

<p>Enable the given setting <em>name</em>:</p>

<pre>
server.enable('some arbitrary setting');
server.set('some arbitrary setting');
// =&gt; true

server.enabled('some arbitrary setting');
// =&gt; true
</pre>

<h2 id="server.enabled()">server.enabled(name)</h2>

<p>Check if setting <em>name</em> is enabled:</p>

<pre>
server.enabled('view cache');
// =&gt; false

server.enable('view cache');
server.enabled('view cache');
// =&gt; true
</pre>

<h2 id="server.disable()">server.disable(name)</h2>

<p>Disable the given setting <em>name</em>:</p>

<pre>
server.disable('some setting');
server.set('some setting');
// =&gt; false

server.disabled('some setting');
// =&gt; false

</pre>

<h2 id="server.disabled()">server.disabled(name)</h2>

<p>Check if setting <em>name</em> is disabled:</p>

<pre>
server.enable('view cache');

server.disabled('view cache');
// =&gt; false

server.disable('view cache');
server.disabled('view cache');
// =&gt; true
</pre>

<h2 id="server.configure()">server.configure(env|function[, function])</h2>

<p>Define a callback function for the given <em>env</em> (or all environments) with callback <em>function</em>:</p>

<pre>
server.configure(function(){
  // executed for each env
});

server.configure('development', function(){
  // executed for 'development' only
});
</pre>

<div class="not-implemented-message"><b>"PARTLY IMPLEMENTED"</b></div>
<h2 id="server.redirect()">server.redirect(name, val)</h2>

<p>For use with <em>response.redirect()</em> we can map redirects at the serverlication level as shown below:</p>

<pre>
server.redirect('google', 'http://google.com');
</pre>

<p>Now in a route we may call:</p>

<p>response.redirect(&lsquo;google&rsquo;);</p>

<p>We may also map dynamic redirects:</p>

<pre>
server.redirect('comments', function(request, response){
  return '/post/' + request.params.id + '/comments';
});
</pre>

<p>So now we may do the following, and the redirect will dynamically adjust to
the context of the request. If we called this route with <em>GET /post/12</em> our
redirect <em>Location</em> would be <em>/post/12/comments</em>.</p>

<pre>
server.get('/post/:id', function(request, response){
  response.redirect('comments');
});
</pre>

<p>When mounted, <em>response.redirect()</em> will respect the mount-point. For example if a blog server is mounted at <em>/blog</em>, the following will redirect to <em>/blog/posts</em>:</p>

<pre>
response.redirect('/posts');
</pre>

<div class="not-implemented-message"><b>"NOT IMPLEMENTED"</b></div>
<h2 id="server.error()">server.error(function)</h2>

<p>Adds an error handler <em>function</em> which will receive the exception as the first parameter as shown below.
Note that we may set several error handlers by making several calls to this method, however the handler
should call <em>next(err)</em> if it does not wish to deal with the exception:</p>

<pre>
server.error(function(err, req, res, next){
  response.send(err.message, 500);
});
</pre>

<div class="not-implemented-message"><b>"NOT IMPLEMENTED"</b></div>
<h2 id="server.helpers()">server.helpers(obj)</h2>

<p>Registers static view helpers.</p>

<pre>
server.helpers({
    name: function(first, last){ return first + ', ' + last }
  , firstName: 'tj'
  , lastName: 'holowaychuk'
});
</pre>

<p>Our view could now utilize the <em>firstName</em> and <em>lastName</em> variables,
as well as the <em>name()</em> function exposed.</p>

<pre>
&lt;%= name(firstName, lastName) %&gt;
</pre>

<p>Express also provides a few locals by default:</p>

<pre>
- `settings`  the server's settings object
- `filename`  the view's filename
- `layout(path)`  specify the layout from within a view
</pre>

<p>This method is aliased as <em>server.locals()</em>.</p>

<div class="not-implemented-message"><b>"NOT IMPLEMENTED"</b></div>
<h2 id="server.dynamichelpers()">server.dynamicHelpers(obj)</h2>

<p>Registers dynamic view helpers. Dynamic view helpers
are simply functions which accept <em>req</em>, <em>res</em>, and are
evaluated against the <em>Server</em> instance before a view is rendered. The <em>return value</em> of this function
becomes the local variable it is associated with.</p>

<pre>
server.dynamicHelpers({
  session: function(request, response){
    return request.session;
  }
});
</pre>

<p>All views would now have <em>session</em> available so that session data can be accessed via <em>session.name</em> etc:</p>

<pre>&lt;%= session.name %&gt;
</pre>

<div class="not-implemented-message"><b>"NOT IMPLEMENTED"</b></div>
<h2 id="server.lookup">server.lookup</h2>

<p> The <em>server.lookup</em> http methods returns an array of callback functions
 associated with the given <em>path</em>.</p>

<p> Suppose we define the following routes:</p>

<pre>
server.get('/user/:id', function(){});
server.put('/user/:id', function(){});
server.get('/user/:id/:op?', function(){});
</pre>

<p>We can utilize this lookup functionality to check which routes
  have been defined, which can be extremely useful for higher level
  frameworks built on Express.</p>

<pre>  
server.lookup.get('/user/:id');
// =&gt; [Function]

server.lookup.get('/user/:id/:op?');
// =&gt; [Function]

server.lookup.put('/user/:id');
// =&gt; [Function]

server.lookup.all('/user/:id');
// =&gt; [Function, Function]

server.lookup.all('/hey');
// =&gt; []
</pre>

<p>  To alias <em>server.lookup.VERB()</em>, we can simply invoke <em>server.VERB()</em>
  without a callback, as a shortcut, for example the following are
  equivalent:</p>

<pre>
server.lookup.get('/user');
server.get('/user');
</pre>

<p>Each function returned has the following properties:</p>

<pre>  
var fn = server.get('/user/:id/:op?')[0];

fn.regexp
// =&gt; /^\/user\/(?:([^\/]+?))(?:\/([^\/]+?))?\/?$/i

fn.keys
// =&gt; ['id', 'op']

fn.path
// =&gt; '/user/:id/:op?'

fn.method
// =&gt; 'GET'
</pre>

<div class="not-implemented-message"><b>"PARTLY IMPLEMENTED"</b></div>
<h2 id="server.match">server.match</h2>

<p>  The <em>server.match</em> http methods return an array of callback functions
  which match the given <em>url</em>, which may include a query string etc. This
  is useful when you want reflect on which routes have the opportunity to
  respond.</p>

<p>  Suppose we define the following routes:</p>

<pre>
server.get('/user/:id', function(){});
server.put('/user/:id', function(){});
server.get('/user/:id/:op?', function(){});
</pre>

<p>  Our match against <strong>GET</strong> will return two functions, since the <em>:op</em>
  in our second route is optional.</p>

<pre>  
server.match.get('/user/1');
// =&gt; [Function, Function]
</pre>

<p>  This second call returns only the callback for <em>/user/:id/:op?</em>.</p>

<pre>  
server.match.get('/user/23/edit');
// =&gt; [Function]
</pre>

<p>  We can also use <em>all()</em> to disregard the http method:</p>

<pre>  
server.match.all('/user/20');
// =&gt; [Function, Function, Function]
</pre>

<p>  Each function matched has the following properties:</p>

<pre>
var fn = server.match.get('/user/23/edit')[0];

fn.keys
// =&gt; ['id', 'op']

fn.params
// =&gt; { id: '23', op: 'edit' }

fn.method
// =&gt; 'GET'
</pre>

<div class="not-implemented-message"><b>"NOT IMPLEMENTED"</b></div>
<h2 id="server.mounted()">server.mounted(fn)</h2>

<p>Assign a callback <em>fn</em> which is called when this <em>Server</em> is passed to <em>Server#use()</em>.</p>

<pre>var server = express.createServer(),
    blog = express.createServer();

blog.mounted(function(parent){
  // parent is server
  // "this" is blog
});

server.use(blog);
</pre>

<h2 id="server.register()">server.register(ext, exports)</h2>

<p>Register the given template engine <em>exports</em>
as <em>ext</em>. For example we may wish to map &ldquo;.html&rdquo;
files to jade:</p>

<pre>
server.register('.html', require('jade'));
</pre>

<p>This is also useful for libraries that may not
match extensions correctly. For example my haml.js
library is installed from npm as &ldquo;hamljs&rdquo; so instead
of layout.hamljs, we can register the engine as &ldquo;.haml&rdquo;:</p>

<pre>
server.register('.haml', require('haml-js'));
</pre>

<p>For engines that do not comply with the Express
specification, we can also wrap their api this way. Below
we map <em>.md</em> to render markdown files, rendering the html once
since it will not change on subsequent calls, and support local substitution
in the form of &ldquo;{name}&rdquo;.</p>

<pre>
server.register('.md', {
  compile: function(str, options){
    var html = md.toHTML(str);
    return function(locals){
      return html.replace(/\{([^}]+)\}/g, function(_, name){
        return locals[name];
      });
    };
  }
});
</pre>

<h2 id="server.listen()">server.listen()</h2>

<p>Bind the server to the following events: <em>onClick</em>, <em>onSubmit</em> and <em>onPopState</em> which means that it will intercept clicking of links and submitting of forms and also the back and forward actions. <em>server.listen()</em> also triggers the loading of the configuration functions after the DOM is loaded.</p>

<pre>server.listen();</pre>
